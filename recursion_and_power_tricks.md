# Конспект по лекции 4: Рекурсия, сортировка слиянием, башни и побитовые трюки

## Факториал — рекурсивный подход

### Теория:
Функция вызывает саму себя до тех пор, пока не достигнет базового случая `n == 0` или `n == 1`. На каждом шаге функция умножает текущее число на факториал от (n - 1).

### Код:
```python
def factorial(n):
    if n == 0 or n == 1:
        return 1
    return n * factorial(n - 1)
```

## Числа Фибоначчи — наивная рекурсия

### Теория:
Каждое число равно сумме двух предыдущих. Рекурсивный вызов приводит к экспоненциальной сложности — O(2^n), из-за переиспользования одних и тех же значений.

### Код:
```python
def fib(n):
    if n == 1 or n == 2:
        return 1
    return fib(n - 1) + fib(n - 2)
```

## Числа Фибоначчи — рекурсия с кэшированием (мемоизация)

### Теория:
Оптимизация наивной рекурсии путём хранения уже вычисленных значений. Снижается количество вызовов, асимптотика — O(n).

### Код:
```python
from functools import lru_cache

@lru_cache(maxsize=None)
def fib(n):
    if n == 1 or n == 2:
        return 1
    return fib(n - 1) + fib(n - 2)
```

## Сумма элементов списка — рекурсивно

### Теория:
Базовый случай — список из одного элемента. Рекурсивно откусываем последний элемент и складываем с суммой оставшегося списка.

### Код:
```python
def recursive_sum(lst):
    if len(lst) == 1:
        return lst[0]
    return lst[-1] + recursive_sum(lst[:-1])
```

## Задача о Ханойских башнях

### Теория:
Переносим n дисков с одного стержня на другой, используя третий как промежуточный. Сложность — O(2^n). Рекурсивно решаем через перемещение n−1 дисков, затем самого большого, и ещё раз n−1.

### Код:
```python
def hanoi(n, source, target, auxiliary):
    if n == 1:
        print(f"Move disk 1 from {source} to {target}")
    else:
        hanoi(n - 1, source, auxiliary, target)
        print(f"Move disk {n} from {source} to {target}")
        hanoi(n - 1, auxiliary, target, source)
```

## Проверка, является ли число степенью двойки (битовые операции)

### Теория:
Для степени двойки в двоичном представлении всегда только одна 1. Тогда `n & (n - 1) == 0` означает, что n — степень двойки. Работает за O(1).

### Код:
```python
def is_power_of_two(n):
    return n > 0 and (n & (n - 1)) == 0
```

## Быстрое (бинарное) возведение в степень

### Теория:
Рекурсивный алгоритм, уменьшающий степень вдвое. При чётной степени возводим (a ^ (n/2))², при нечётной — (a ^ (n-1)) * a. Сложность — O(log n).

### Код:
```python
def binpow(a, n):
    if n == 0:
        return 1
    if n % 2 == 0:
        half = binpow(a, n // 2)
        return half * half
    else:
        return binpow(a, n - 1) * a
```
